-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Problemas de Exercitium (Volumen 1)
--   
--   Durante el curso 2013-14 se creó el blog <a>Exercitium</a> como
--   complemento del curso de <a>Informática</a> de 1º del Grado de
--   Matemáticas de la Universidad de Sevilla.
--   
--   El objetivo de <a>Exercitium</a> es plantear diariamente un problema
--   para que los alumnos pudieran practicar y escribir distintas
--   soluciones en los comentarios.
--   
--   Esta librería es una recopilación de los ejercicios propuestos en
--   <a>Exercitium</a> durante el curso 2013-14.
@package Exercitium1
@version 0.1.0.0


-- | Los polinomios se pueden representar mediante vectores usando la
--   librería Data.Array. En primer lugar, se define el tipo de los
--   polinomios (con coeficientes de tipo a) mediante
--   
--   <pre>
--   type Polinomio a = Array Int a
--   </pre>
--   
--   Como ejemplos, definimos el polinomio
--   
--   <pre>
--   ej_pol1 :: Array Int Int
--   ej_pol1 = array (0,4) [(1,2),(2,-5),(4,7),(0,6),(3,0)]
--   </pre>
--   
--   que representa a 2x - 5x^2 + 7x^4 + 6 y el polinomio
--   
--   <pre>
--   ej_pol2 :: Array Int Double
--   ej_pol2 = array (0,4) [(1,2),(2,-5.2),(4,7),(0,6.5),(3,0)]
--   </pre>
--   
--   que representa a 2x - 5.2x^2 + 7x^4 + 6.5
--   
--   Definir la función
--   
--   <pre>
--   valor :: Num a =&gt; Polinomio a -&gt; a -&gt; a
--   </pre>
--   
--   tal que (valor p b) es el valor del polinomio p en el punto b. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; valor ej_pol1 0
--   6
--   
--   &gt;&gt;&gt; valor ej_pol1 1
--   10
--   
--   &gt;&gt;&gt; valor ej_pol1 2
--   102
--   
--   &gt;&gt;&gt; valor ej_pol2 0
--   6.5
--   
--   &gt;&gt;&gt; valor ej_pol2 1
--   10.3
--   
--   &gt;&gt;&gt; valor ej_pol2 3
--   532.7
--   </pre>
module Valor_de_un_polinomio

-- | Tipo de polinomios
type Polinomio a = Array Int a

-- | Ejemplo de polinomio: 2x - 5x^2 + 7x^4 + 6
ej_pol1 :: Array Int Int

-- | Ejemplo de polinomio: 2x - 5.2x^2 + 7x^4 + 6.5
ej_pol2 :: Array Int Double

-- | 1ª definición.
valor :: Num a => Polinomio a -> a -> a

-- | 2ª definición.
valor2 :: Num a => Polinomio a -> a -> a

-- | Comprueba la equivalencia de las definiciones de valor.
--   
--   <pre>
--   &gt;&gt;&gt; equivalencia_valor
--   +++ OK, passed 100 tests.
--   </pre>
equivalencia_valor :: IO ()


-- | Definir la función
--   
--   <pre>
--   sumaSiTodosJustos :: (Num a, Eq a) =&gt; [Maybe a] -&gt; Maybe a
--   </pre>
--   
--   tal que <b>(sumaSiTodosJustos xs)</b> es justo la suma de todos los
--   elementos de xs si todos son justos (es decir, si Nothing no pertenece
--   a xs) y Nothing en caso contrario. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sumaSiTodosJustos [Just 2, Just 5]
--   Just 7
--   
--   &gt;&gt;&gt; sumaSiTodosJustos [Just 2, Just 5, Nothing]
--   Nothing
--   </pre>
module Suma_si_todos_justos

-- | 1ª definición
sumaSiTodosJustos :: (Num a, Eq a) => [Maybe a] -> Maybe a

-- | Verificación
verifica_sumaSiTodosJustos :: IO ()


-- | Definir la función
--   
--   <pre>
--   segmentos :: (Enum a, Eq a) =&gt; [a] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(segmentos xss)</b> es la lista de los segmentos de xss
--   formados por elementos consecutivos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; segmentos [1,2,5,6,4]
--   [[1,2],[5,6],[4]]
--   
--   &gt;&gt;&gt; segmentos [1,2,3,4,7,8,9]
--   [[1,2,3,4],[7,8,9]]
--   
--   &gt;&gt;&gt; segmentos "abbccddeeebc"
--   ["ab","bc","cd","de","e","e","bc"]
--   </pre>
--   
--   Nota: Se puede usar la función succ tal que (succ x) es el sucesor de
--   x. Por ejemplo,
--   
--   <pre>
--   succ 3    ==  4
--   succ 'c'  ==  'd'
--   </pre>
module Segmentos_consecutivos

-- | 1ª definición (por recursión).
segmentos :: (Enum a, Eq a) => [a] -> [[a]]

-- | 2ª definición.
segmentos2 :: (Enum a, Eq a) => [a] -> [[a]]

-- | (inicial xs) es el segmento inicial de xs formado por elementos
--   consecutivos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; inicial [1,2,5,6,4]
--   [1,2]
--   
--   &gt;&gt;&gt; inicial "abccddeeebc"
--   "abc"
--   </pre>
inicial :: (Enum a, Eq a) => [a] -> [a]

-- | 2ª definición de inicial (con uncurry)
--   
--   <pre>
--   &gt;&gt;&gt; inicial2 [1,2,5,6,4]
--   [1,2]
--   
--   &gt;&gt;&gt; inicial2 "abccddeeebc"
--   "abc"
--   </pre>
inicial2 :: (Enum a, Eq a) => [a] -> [a]

-- | (prop_segmentos xs) se verifica si las definiciones de segmentos son
--   equivalentes sobre xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_segmentos [1,2,5,6,4]
--   True
--   
--   &gt;&gt;&gt; prop_segmentos [1,2,3,4,7,8,9]
--   True
--   
--   &gt;&gt;&gt; prop_segmentos "abbccddeeebc"
--   True
--   </pre>
prop_segmentos :: (Enum a, Eq a) => [a] -> Bool

-- | Comprueba la equivalencia de las definiciones de segmentos.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_segmentos
--   +++ OK, passed 100 tests.
--   </pre>
verifica_segmentos :: IO ()


-- | En los siguientes dibujos se observa que el número máximo de regiones
--   en el plano generadas con 1, 2 ó 3 líneas son 2, 4 ó 7,
--   respectivamente.
--   
--   <pre>
--                      \  |
--                       \5|
--                        \|
--                         \
--                         |\
--                         | \
--               |         |  \ 
--    1        1 | 3     1 | 3 \  6
--   ------   ---|---   ---|----\---
--    2        2 | 4     2 | 4   \ 7
--               |         |      \
--   </pre>
--   
--   Definir la función
--   
--   <pre>
--   regiones :: Integer -&gt; Integer  
--   </pre>
--   
--   tal que <b>(regiones n)</b> es el número máximo de regiones en el
--   plano generadas con n líneas. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; regiones 3
--   7  
--   
--   &gt;&gt;&gt; regiones 100
--   5051
--   </pre>
module Regiones

-- | 1ª definición (por recursión).
regiones :: Integer -> Integer

-- | 2ª definición (por la fórmula).
regiones2 :: Integer -> Integer

-- | <b>(prop_regiones n)</b> se verifica si las definiciones de regiones
--   son equivalentes sobre n. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; all prop_regiones [Positive 2, Positive 100]
--   True
--   
--   &gt;&gt;&gt; quickCheck prop_regiones
--   +++ OK, passed 100 tests.
--   </pre>
prop_regiones :: (Positive Integer) -> Bool


-- | Los árboles se pueden representar mediante el siguiente tipo de datos
--   
--   <pre>
--   data Arbol a = N a [Arbol a]
--                  deriving Show
--   </pre>
--   
--   Por ejemplo, los árboles
--   
--   <pre>
--     1               3
--    / \             /|\ 
--   2  3            / | \
--      |           5  4  7
--      4           |     /\ 
--                  6    2  1
--   </pre>
--   
--   se representan por
--   
--   <pre>
--   ej1, ej2 :: Arbol Int
--   ej1 = N 1 [N 2 [],N 3 [N 4 []]]
--   ej2 = N 3 [N 5 [N 6 []], N 4 [], N 7 [N 2 [], N 1 []]
--   </pre>
--   
--   Definir la función
--   
--   <pre>
--   ramas :: Arbol b -&gt; [[b]]
--   </pre>
--   
--   tal que (ramas a) es la lista de las ramas del árbol a. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; ramas ej1
--   [[1,2],[1,3,4]]
--   
--   &gt;&gt;&gt; ramas ej2
--   [[3,5,6],[3,4],[3,7,2],[3,7,1]]
--   </pre>
module Ramas_de_un_arbol

-- | Tipo de los árboles.
data Arbol a
N :: a -> [Arbol a] -> Arbol a

-- | Ejemplo de árbol.
ej1 :: Arbol Int

-- | Ejemplo de árbol.
ej2 :: Arbol Int

-- | 1ª solución (por recursión y comprensión).
ramas :: Arbol b -> [[b]]

-- | 2ª solución (por recursión con <a>map</a> y <a>concat</a>).
ramas2 :: Arbol b -> [[b]]

-- | 3ª solución (por recursión con <a>concatMap</a>).
ramas3 :: Arbol b -> [[b]]

-- | 4ª solución (por recursión con <a>concatMap</a> y <a>.</a>
ramas4 :: Arbol b -> [[b]]

-- | 5ª solución (por recursión con <a>map</a> y <a>&gt;&gt;=</a>
ramas5 :: Arbol a -> [[a]]

-- | Generador de árboles.
--   
--   <pre>
--   &gt; sample ((gen_Arbol 5) :: Gen (Arbol Int))
--   N 0 [N 0 []]
--   N (-2) []
--   N 4 []
--   N 2 [N 4 []]
--   N 8 []
--   N (-2) [N (-9) [],N 7 []]
--   N 11 []
--   N (-11) [N 4 [],N 14 []]
--   N 10 [N (-3) [],N 13 []]
--   N 12 [N 11 []]
--   N 20 [N (-18) [],N (-13) []]
--   </pre>
gen_Arbol :: Arbitrary a => Int -> Gen (Arbol a)

-- | Incluye los árboles en Arbitrary.

-- | Comprueba la equivalencia de las definiciones de ramas.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_ramas
--   +++ OK, passed 100 tests.
--   </pre>
prop_ramas :: Arbol Int -> Bool
instance GHC.Show.Show a => GHC.Show.Show (Ramas_de_un_arbol.Arbol a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Ramas_de_un_arbol.Arbol a)


-- | Definir la función
--   
--   <pre>
--   primosEquidistantes :: Integer -&gt; [(Integer,Integer)]
--   </pre>
--   
--   tal que <b>(primosEquidistantes k)</b> es la lista de los pares de
--   primos cuya diferencia es k. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; take 3 (primosEquidistantes 2)
--   [(3,5),(5,7),(11,13)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 4)
--   [(7,11),(13,17),(19,23)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 6)
--   [(23,29),(31,37),(47,53)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 8)
--   [(89,97),(359,367),(389,397)]
--   </pre>
module Primos_equidistantes

-- | 1ª definición
primosEquidistantes :: Integer -> [(Integer, Integer)]

-- | 2ª definición
--   
--   <pre>
--   &gt;&gt;&gt; take 20 (primosEquidistantes2 2) == take 20 (primosEquidistantes 2)
--   True
--   
--   &gt;&gt;&gt; take 20 (primosEquidistantes2 4) == take 20 (primosEquidistantes 4)
--   True
--   </pre>
primosEquidistantes2 :: Integer -> [(Integer, Integer)]


-- | Definir las funciones
--   
--   <pre>
--   primosConsecutivosConMediaCapicua :: [(Int,Int,Int)]
--   nPrimosConsecutivosConMediaCapicua :: Int -&gt; Int
--   </pre>
--   
--   tales que
--   
--   <ul>
--   <li><b>primosConsecutivosConMediaCapicua</b> es la lista de las ternas
--   (x,y,z) tales que x e y son primos consecutivos cuya media, z, es
--   capicúa. Por ejemplo,</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 primosConsecutivosConMediaCapicua
--   [(3,5,4),(5,7,6),(7,11,9),(97,101,99),(109,113,111)]
--   </pre>
--   
--   <ul>
--   <li><b>(nPrimosConsecutivosConMediaCapicua n)</b> es el número de
--   ternas de primos consecutivos con media capicua que son menores que n.
--   Por ejemplo,</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; nPrimosConsecutivosConMediaCapicua 2014
--   20
--   </pre>
module Primos_consecutivos_con_media_capicua

-- | 1ª definición (definiendo los primos)
primosConsecutivosConMediaCapicua :: [(Int, Int, Int)]

-- | (primo x) se verifica si x es primo. Por ejemplo, &gt;&gt;&gt; primo 7
--   True &gt;&gt;&gt; primo 8 False
primo :: Int -> Bool

-- | primos es la lista de los números primos mayores que 2. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; take 10 primos
--   [3,5,7,11,13,17,19,23,29,31]
--   </pre>
primos :: [Int]

-- | (capicua x) se verifica si x es capicúa. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; capicua 32723
--   True
--   
--   &gt;&gt;&gt; capicua 32732
--   False
--   </pre>
capicua :: Int -> Bool

-- | 2ª definición (con primes)
primosConsecutivosConMediaCapicua2 :: [(Int, Int, Int)]

-- | (verifica_primosConsecutivosConMediaCapicua n =) se verifica si las
--   definiciones de primosConsecutivosConMediaCapicua son equivalentes
--   para los n primeros elementos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; verifica_primosConsecutivosConMediaCapicua 20
--   True
--   </pre>
verifica_primosConsecutivosConMediaCapicua :: Int -> Bool

-- | Definición de nPrimosConsecutivosConMediaCapicua
nPrimosConsecutivosConMediaCapicua :: Int -> Int


-- | Definir la función
--   
--   <pre>
--   numeroParesAdyacentesIguales :: Eq a =&gt; [[a]] -&gt; Int
--   </pre>
--   
--   tal que <b>(numeroParesAdyacentesIguales xss)</b> es el número de
--   pares de elementos consecutivos (en la misma fila o columna) iguales
--   de la matriz xss. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; numeroParesAdyacentesIguales [[0,1],[0,2]]
--   1
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIguales [[0,0],[1,2]]
--   1
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIguales [[0,1],[0,0]]
--   2
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIguales [[1,2],[1,4],[4,4]]
--   3
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIguales ["ab","aa"]
--   2
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIguales [[0,0,0],[0,0,0],[0,0,0]]
--   12
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIguales [[0,0,0],[0,1,0],[0,0,0]]
--   8
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIguales [[0,0,0,0],[0,0,0,0],[0,0,0,0::Int]]
--   17
--   </pre>
module Pares_adyacentes_iguales

-- | 1ª definición (Por comprensión).
numeroParesAdyacentesIguales :: Eq a => [[a]] -> Int

-- | <b>(numeroParesAdyacentesIgualesFilas xss)</b> es el número de pares
--   de elementos consecutivos (en la misma fila) iguales de la matriz xss.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; numeroParesAdyacentesIgualesFilas [[0,0,1,0],[0,1,1,0],[0,1,0,1]]
--   2
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIgualesFilas ["0010","0110","0101"]
--   2
--   </pre>
numeroParesAdyacentesIgualesFilas :: Eq a => [[a]] -> Int

-- | <b>(numeroParesAdyacentesIgualesFila xs)</b> es el número de pares de
--   elementos consecutivos de la lista xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; numeroParesAdyacentesIgualesFila "0010"
--   1
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIgualesFila "0110"
--   1
--   
--   &gt;&gt;&gt; numeroParesAdyacentesIgualesFila "0101"
--   0
--   </pre>
numeroParesAdyacentesIgualesFila :: Eq a => [a] -> Int

-- | 2ª definición de <a>numeroParesAdyacentesIgualesFilas</a> (con
--   <a>map</a>).
numeroParesAdyacentesIgualesFilas2 :: Eq a => [[a]] -> Int

-- | 3ª definición de <a>numeroParesAdyacentesIgualesFilas</a> (sin
--   argumentos).
numeroParesAdyacentesIgualesFilas3 :: Eq a => [[a]] -> Int

-- | Comprobación de la equivalencia de las definiciones de
--   numeroParesAdyacentesIgualesFilas.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_numeroParesAdyacentesIgualesFilas
--   +++ OK, passed 100 tests.
--   </pre>
prop_numeroParesAdyacentesIgualesFilas :: [[Int]] -> Bool

-- | 2ª definición de <a>numeroParesAdyacentesIguales</a> (Por
--   composición).
numeroParesAdyacentesIguales2 :: Eq a => [[a]] -> Int

-- | 3ª definición de <a>numeroParesAdyacentesIguales</a> (con matrices)
numeroParesAdyacentesIguales3 :: Eq a => [[a]] -> Int

-- | 4ª definición de <a>numeroParesAdyacentesIguales</a> (sin argumentos)
numeroParesAdyacentesIguales4 :: Eq a => [[a]] -> Int

-- | Tipo de matrices.
newtype Matriz
M :: [[Int]] -> Matriz

-- | <b>matriz</b> es un generador de matrices. Por ejemplo,
--   
--   <pre>
--   &gt; sample matriz
--   M [[0,0]]
--   M [[1,-2,-2],[-2,2,0],[2,-1,-2],[-2,0,-2]]
--   M [[3,-4,0,0,2],[2,2,0,-2,2],[-1,-4,2,-3,0],[0,4,-1,-2,-3],[-3,-4,0,-4,-2]]
--   M [[1,3],[2,-3],[0,3],[-3,2]]
--   M [[-3,-3,-4,2,-6,0],[5,-6,3,-2,2,-8],[-6,8,5,1,0,-7],[7,3,7,-8,-3,-2]]
--   M [[-9,7,0]]
--   M [[8,-1,11,8,-13,9],[12,13,12,1,0,-9],[3,-4,7,-1,5,-2]]
--   M [[-3,16,-9,-14,15,-6],[7,-14,8,-10,7,2]]
--   </pre>
matriz :: Gen Matriz

-- | <b>(listaAmatriz m xs)</b> es la matriz con m columnas cuyos elementos
--   son los de xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; listaAmatriz 3 [2,1,5,4,7,9]
--   [[2,1,5],[4,7,9]]
--   
--   &gt;&gt;&gt; listaAmatriz 2 [2,1,5,4,7,9]
--   [[2,1],[5,4],[7,9]]
--   </pre>
listaAmatriz :: Int -> [a] -> [[a]]

-- | <b>(prop_numeroParesAdyacentesIguales (M xss))</b> se verifica si las
--   definiciones de numeroParesAdyacentesIguales son equivalentes sobre
--   xss. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    all prop_numeroParesAdyacentesIguales
--        [M [[0,1],[0,2]],
--         M [[0,0],[1,2]],
--         M [[0,1],[0,0]],
--         M [[1,2],[1,4],[4,4]],
--         M [[0,0,0],[0,0,0],[0,0,0]],
--         M [[0,0,0],[0,1,0],[0,0,0]],
--         M [[0,0,0,0],[0,0,0,0],[0,0,0,0]]]
--   :}
--   True
--   </pre>
prop_numeroParesAdyacentesIguales :: Matriz -> Bool

-- | Comprueba la equivalencia de todas las definiciones de
--   numeroParesAdyacentesIguales.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_numeroParesAdyacentesIguales
--   +++ OK, passed 100 tests.
--   </pre>
verifica_numeroParesAdyacentesIguales :: IO ()
instance GHC.Show.Show Pares_adyacentes_iguales.Matriz


-- | Definir la función
--   
--   <pre>
--   ordenadosPorMaximo :: Ord a =&gt; [[a]] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(ordenadosPorMaximo xss)</b> es la lista de los elementos
--   de xss ordenada por sus máximos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; ordenadosPorMaximo [[3,2],[6,7,5],[1,4]]
--   [[3,2],[1,4],[6,7,5]]
--   
--   &gt;&gt;&gt; ordenadosPorMaximo ["este","es","el","primero"]
--   ["el","primero","es","este"]
--   </pre>
module Ordenados_por_maximo

-- | 1ª definición
ordenadosPorMaximo :: Ord a => [[a]] -> [[a]]

-- | 2ª definición
ordenadosPorMaximo2 :: Ord a => [[a]] -> [[a]]

-- | (prop_ordenadosPorMaximo xs) se verifica si todas las definiciones de
--   ordenadosPorMaximo son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_ordenadosPorMaximo [[3,2],[6,7,5],[1,4]]
--   True
--   
--   &gt;&gt;&gt; prop_ordenadosPorMaximo ["este","es","el","primero"]
--   True
--   </pre>
prop_ordenadosPorMaximo :: Ord a => [[a]] -> Bool

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verificaOrdenadosPorMaximo
--   +++ OK, passed 100 tests.
--   </pre>
verificaOrdenadosPorMaximo :: IO ()


-- | Las notas de los dos primeros exámenes se pueden representar mediante
--   el siguiente tipo de dato
--   
--   <pre>
--   data Notas = Notas String Int Int
--                deriving (Read, Show, Eq)
--   </pre>
--   
--   Por ejemplo, (Notas <a>Juan</a> 6 5) representar las notas de un
--   alumno cuyo nombre es Juan, la nota del primer examen es 6 y la del
--   segundo es 5.
--   
--   Definir la función
--   
--   <pre>
--   ordenadas :: [Notas] -&gt; [Notas]
--   </pre>
--   
--   tal que <b>(ordenadas ns)</b> es la lista de las notas ns ordenadas
--   considerando primero la nota del examen 2, a continuación la del
--   examen 1 y finalmente el nombre. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; ordenadas [Notas "Juan" 6 5, Notas "Luis" 3 7]
--   [Notas "Juan" 6 5,Notas "Luis" 3 7]
--   
--   &gt;&gt;&gt; ordenadas [Notas "Juan" 6 5, Notas "Luis" 3 4]
--   [Notas "Luis" 3 4,Notas "Juan" 6 5]
--   
--   &gt;&gt;&gt; ordenadas [Notas "Juan" 6 5, Notas "Luis" 7 4]
--   [Notas "Luis" 7 4,Notas "Juan" 6 5]
--   
--   &gt;&gt;&gt; ordenadas [Notas "Juan" 6 4, Notas "Luis" 7 4]
--   [Notas "Juan" 6 4,Notas "Luis" 7 4]
--   
--   &gt;&gt;&gt; ordenadas [Notas "Juan" 6 4, Notas "Luis" 5 4]
--   [Notas "Luis" 5 4,Notas "Juan" 6 4]
--   
--   &gt;&gt;&gt; ordenadas [Notas "Juan" 5 4, Notas "Luis" 5 4]
--   [Notas "Juan" 5 4,Notas "Luis" 5 4]
--   
--   &gt;&gt;&gt; ordenadas [Notas "Juan" 5 4, Notas "Eva" 5 4]
--   [Notas "Eva" 5 4,Notas "Juan" 5 4]
--   </pre>
module Ordenacion_de_estructuras

-- | Tipo se las notas.
data Notas
Notas :: String -> Int -> Int -> Notas

-- | Definición.
ordenadas :: [Notas] -> [Notas]
instance GHC.Classes.Eq Ordenacion_de_estructuras.Notas
instance GHC.Show.Show Ordenacion_de_estructuras.Notas
instance GHC.Read.Read Ordenacion_de_estructuras.Notas


-- | Las ternas de números naturales se pueden ordenar como sigue
--   
--   <pre>
--   (0,0,0), 
--   (0,0,1),(0,1,0),(1,0,0),
--   (0,0,2),(0,1,1),(0,2,0),(1,0,1),(1,1,0),(2,0,0),
--   (0,0,3),(0,1,2),(0,2,1),(0,3,0),(1,0,2),(1,1,1),(1,2,0),(2,0,1),(2,1,0),(3,0,0),
--   ...
--   </pre>
--   
--   Definir la función
--   
--   <pre>
--   posicion :: (Int,Int,Int) -&gt; Int
--   </pre>
--   
--   tal que <b>(posicion t)</b> es la posición de la terna de números
--   naturales t en la ordenación anterior. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; posicion (0,1,0)
--   2
--   
--   &gt;&gt;&gt; posicion (0,0,2)
--   4
--   
--   &gt;&gt;&gt; posicion (0,1,1)
--   5
--   </pre>
module Numeracion_de_ternas

-- | Definición.
posicion :: (Int, Int, Int) -> Int

-- | ternas es la lista ordenada de las ternas de números naturales. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; take 10 ternas
--   [(0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,0,2),(0,1,1),(0,2,0),(1,0,1),(1,1,0),(2,0,0)]
--   </pre>
ternas :: [(Int, Int, Int)]


-- | Los árboles se pueden representar mediante el siguiente tipo de datos
--   
--   <pre>
--   data Arbol a = N a [Arbol a]
--                  deriving Show
--   </pre>
--   
--   Por ejemplo, los árboles
--   
--   <pre>
--      1              3
--    /  \            /|\ 
--   2   3           / | \
--       |          5  4  7
--       4          |     /\ 
--                  6    2  1
--   </pre>
--   
--   se representan por
--   
--   <pre>
--   ej1, ej2 :: Arbol Int
--   ej1 = N 1 [N 2 [],N 3 [N 4 []]]
--   ej2 = N 3 [N 5 [N 6 []], N 4 [], N 7 [N 2 [], N 1 []]]
--   </pre>
--   
--   Definir la función
--   
--   <pre>
--   mayorProducto :: (Ord a, Num a) =&gt; Arbol a -&gt; a
--   </pre>
--   
--   tal que <b>(mayorProducto a)</b> es el mayor producto de las ramas del
--   árbol a. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; mayorProducto (N 1 [N 2 [], N  3 []])
--   3
--   
--   &gt;&gt;&gt; mayorProducto (N 1 [N 8 [], N  4 [N 3 []]])
--   12
--   
--   &gt;&gt;&gt; mayorProducto (N 1 [N 2 [],N 3 [N 4 []]])
--   12
--   
--   &gt;&gt;&gt; mayorProducto (N 3 [N 5 [N 6 []], N 4 [], N 7 [N 2 [], N 1 []]])
--   90
--   
--   &gt;&gt;&gt; mayorProducto (N (-8) [N 0 [N (-9) []],N 6 []])
--   0
--   
--   &gt;&gt;&gt; let a = N (-4) [N (-7) [],N 14 [N 19 []],N (-1) [N (-6) [],N 21 []],N (-4) []]
--   
--   &gt;&gt;&gt; mayorProducto a
--   84
--   </pre>
module Mayor_producto_de_las_ramas_de_un_arbol

-- | Tipo de árboles
data Arbol a
N :: a -> [Arbol a] -> Arbol a

-- | 1º definición.
mayorProducto :: (Ord a, Num a) => Arbol a -> a

-- | <b>(productosRamas a)</b> es la lista de los productos de las ramas
--   del árbol a. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; productosRamas (N 3 [N 5 [N 6 []], N 4 [], N 7 [N 2 [], N 1 []]])
--   [90,12,42,21]
--   </pre>
productosRamas :: (Ord a, Num a) => Arbol a -> [a]

-- | 2ª definición.
mayorProducto2 :: (Ord a, Num a) => Arbol a -> a

-- | <b>(menorProducto a)</b> es el menor producto de las ramas del árbol
--   a. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; menorProducto (N 1 [N 2 [], N  3 []])
--   2
--   
--   &gt;&gt;&gt; menorProducto (N 1 [N 8 [], N  4 [N 3 []]])
--   8
--   
--   &gt;&gt;&gt; menorProducto (N 1 [N 2 [],N 3 [N 4 []]])
--   2
--   
--   &gt;&gt;&gt; menorProducto (N 3 [N 5 [N 6 []], N 4 [], N 7 [N 2 [], N 1 []]])
--   12
--   </pre>
menorProducto :: (Ord a, Num a) => Arbol a -> a

-- | 3ª definición.
mayorProducto3 :: (Ord a, Num a) => Arbol a -> a

-- | <b>(ramas a)</b> es la lista de las ramas del árbol a. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; ramas (N 3 [N 5 [N 6 []], N 4 [], N 7 [N 2 [], N 1 []]])
--   [[3,5,6],[3,4],[3,7,2],[3,7,1]]
--   </pre>
ramas :: Arbol b -> [[b]]

-- | 4ª definición.
mayorProducto4 :: (Ord a, Num a) => Arbol a -> a

-- | 5ª definición.
mayorProducto5 :: (Ord a, Num a) => Arbol a -> a

-- | Generador de árboles.
--   
--   <pre>
--   &gt; sample ((gen_Arbol 5) :: Gen (Arbol Int))
--   N 0 [N 0 []]
--   N (-2) []
--   N 4 []
--   N 2 [N 4 []]
--   N 8 []
--   N (-2) [N (-9) [],N 7 []]
--   N 11 []
--   N (-11) [N 4 [],N 14 []]
--   N 10 [N (-3) [],N 13 []]
--   N 12 [N 11 []]
--   N 20 [N (-18) [],N (-13) []]
--   </pre>
gen_Arbol :: Arbitrary a => Int -> Gen (Arbol a)

-- | Incluye los árboles en Arbitrary.

-- | Comprueba la equivalencia de las definiciones de mayorProducto.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_mayorProducto
--   +++ OK, passed 100 tests.
--   </pre>
prop_mayorProducto :: Arbol Int -> Bool
instance GHC.Show.Show a => GHC.Show.Show (Mayor_producto_de_las_ramas_de_un_arbol.Arbol a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Mayor_producto_de_las_ramas_de_un_arbol.Arbol a)


-- | Un máximo local de una lista es un elemento de la lista que es mayor
--   que su predecesor y que su sucesor en la lista. Por ejemplo, 5 es un
--   máximo local de [3,2,5,3,7,7,1,6,2] ya que es mayor que 2 (su
--   predecesor) y que 3 (su sucesor).
--   
--   Definir la función
--   
--   <pre>
--   maximosLocales :: Ord a =&gt; [a] -&gt; [a]
--   </pre>
--   
--   tal que <b>(maximosLocales xs)</b> es la lista de los máximos locales
--   de la lista xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; maximosLocales [3,2,5,3,7,7,1,6,2]
--   [5,6]
--   
--   &gt;&gt;&gt; maximosLocales [1..100]
--   []
--   
--   &gt;&gt;&gt; maximosLocales "adbpmqexyz"
--   "dpq"
--   </pre>
module MaximosLocales

-- | 1ª definición (por recursión):
maximosLocales :: Ord a => [a] -> [a]

-- | 2ª definición (por comprensión):
maximosLocales2 :: Ord a => [a] -> [a]

-- | (prop_prop_maximosLocales xs) se verifica si las definiciones de
--   maximosLocales son equivalentes sobre xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_maximosLocales [3,2,5,3,7,7,1,6,2]
--   True
--   
--   &gt;&gt;&gt; prop_maximosLocales [1..100]
--   True
--   
--   &gt;&gt;&gt; prop_maximosLocales "adbpmqexyz"
--   True
--   </pre>
prop_maximosLocales :: Ord a => [a] -> Bool

-- | Comprueba la equivalencia de las definiciones de maximosLocales.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_maximosLocales
--   +++ OK, passed 100 tests.
--   </pre>
verifica_maximosLocales :: IO ()


-- | Una matriz de Toeplitz es una matriz cuadrada que es constante a lo
--   largo de las diagonales paralelas a la diagonal principal. Por
--   ejemplo,
--   
--   <pre>
--   |2 5 1 6|       |2 5 1 6|          
--   |4 2 5 1|       |4 2 6 1|
--   |7 4 2 5|       |7 4 2 5|
--   |9 7 4 2|       |9 7 4 2|
--   </pre>
--   
--   la primera es una matriz de Toeplitz y la segunda no lo es.
--   
--   Las anteriores matrices se pueden definir por
--   
--   <pre>
--   ej1, ej2 :: Array (Int,Int) Int
--   ej1 = listArray ((1,1),(4,4)) [2,5,1,6,4,2,5,1,7,4,2,5,9,7,4,2]
--   ej2 = listArray ((1,1),(4,4)) [2,5,1,6,4,2,6,1,7,4,2,5,9,7,4,2]
--   </pre>
--   
--   Definir la función
--   
--   <pre>
--   esToeplitz :: Eq a =&gt; Array (Int,Int) a -&gt; Bool
--   </pre>
--   
--   tal que <b>(esToeplitz p)</b> se verifica si la matriz p es de
--   Toeplitz. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esToeplitz ej1
--   True
--   
--   &gt;&gt;&gt; esToeplitz ej2
--   False
--   </pre>
module Matriz_Toeplitz

-- | Ejemplos de matrices
ej1 :: Array (Int, Int) Int

-- | Ejemplos de matrices
ej2 :: Array (Int, Int) Int

-- | Definición
esToeplitz :: Eq a => Array (Int, Int) a -> Bool


-- | El Mastermind es un juego que consiste en deducir un código numérico
--   formado por una lista de números distintos. Cada vez que se empieza un
--   partido, el programa debe elegir un código, que será lo que el jugador
--   debe adivinar en la menor cantidad de intentos posibles. Cada intento
--   consiste en una propuesta de un código posible que propone el jugador,
--   y una respuesta del programa. Las respuestas le darán pistas al
--   jugador para que pueda deducir el código.
--   
--   Estas pistas indican cuán cerca estuvo el número propuesto de la
--   solución a través de dos valores: la cantidad de aciertos es la
--   cantidad de dígitos que propuso el jugador que también están en el
--   código en la misma posición. La cantidad de coincidencias es la
--   cantidad de digitos que propuso el jugador que también están en el
--   código pero en una posición distinta.
--   
--   Por ejemplo, si el código que eligió el programa es el [2,6,0,7], y el
--   jugador propone el [1,4,0,6], el programa le debe responder un acierto
--   (el 0, que está en el código original en el mismo lugar, el tercero),
--   y una coincidencia (el 6, que también está en el código original, pero
--   en la segunda posición, no en el cuarto como fue propuesto). Si el
--   jugador hubiera propuesto el [3,5,9,1], habría obtenido como respuesta
--   ningún acierto y ninguna coincidencia, ya que no hay números en común
--   con el código original, y si se obtienen cuatro aciertos es porque el
--   jugador adivinó el código y ganó el juego.
--   
--   Definir la función
--   
--   <pre>
--   mastermind :: [Int] -&gt; [Int] -&gt; (Int,Int)
--   </pre>
--   
--   tal que <b>(mastermind xs ys)</b> es el par formado por los números de
--   aciertos y de coincidencias entre xs e ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; mastermind [2,6,0,7] [1,4,0,6]
--   (1,1)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [3,5,9,1]
--   (0,0)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [1,6,0,4]
--   (2,0)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [2,6,0,7]
--   (4,0)
--   </pre>
module Mastermind

-- | 1ª definición
mastermind :: [Int] -> [Int] -> (Int, Int)

-- | (aciertos xs ys) es la lista de aciertos entre xs e ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; aciertos [2,6,0,7] [1,4,0,6]
--   [0]
--   </pre>
aciertos :: Eq a => [a] -> [a] -> [a]

-- | (coincidencia xs ys) es la lista de coincidencias entre xs e ys. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; coincidencias [2,6,0,7] [1,4,0,6]
--   [6]
--   </pre>
coincidencias :: Eq a => [a] -> [a] -> [a]

-- | 2ª definición (por recursión):
mastermind2 :: [Int] -> [Int] -> (Int, Int)

-- | 3ª definición:
mastermind3 :: [Int] -> [Int] -> (Int, Int)

-- | (prop_mastermind xs) se verifica si todas las definiciones de
--   mastermind son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [1,4,0,6]
--   True
--   
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [3,5,9,1]
--   True
--   
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [1,6,0,4]
--   True
--   
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [2,6,0,7]
--   True
--   </pre>
prop_mastermind :: [Int] -> [Int] -> Bool

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verifica_mastermind
--   +++ OK, passed 100 tests.
--   </pre>
verifica_mastermind :: IO ()


-- | Definir la función
--   
--   <pre>
--   masRepetido :: Ord a =&gt; [a] -&gt; (a,Int)
--   </pre>
--   
--   tal que <b>(masRepetido xs)</b> es el mayor elemento de xs que aparece
--   más veces de manera consecutiva en la lista junto con el número de sus
--   apariciones consecutivas. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; masRepetido [1,1,4,4,1]
--   (4,2)
--   
--   &gt;&gt;&gt; masRepetido [4,4,1,1,4]
--   (4,2)
--   
--   &gt;&gt;&gt; masRepetido "aadda"
--   ('d',2)
--   
--   &gt;&gt;&gt; masRepetido "a"
--   ('a',1)
--   
--   &gt;&gt;&gt; masRepetido "ba"
--   ('b',1)
--   </pre>
module Mas_repetido

-- | 1ª definición (por recursión)
masRepetido :: Ord a => [a] -> (a, Int)

-- | <b>(masRepetidos xs)</b> es la lista de los elementos de xs con más
--   repeticiones consecutivas junto con el número de sus repeticiones
--   consecutivas. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; masRepetidos "aabxxbccb"
--   [('a',2),('x',2),('c',2)]
--   </pre>
masRepetidos :: Ord a => [a] -> [(a, Int)]

-- | 2ª definición (con <a>group</a> y <a>maximum</a>).
masRepetido2 :: Ord a => [a] -> (a, Int)

-- | 3ª definición (con <a>group</a>, <a>maximum</a> y <a>swap</a>).
masRepetido3 :: Ord a => [a] -> (a, Int)

-- | 4ª definición (con <a>group</a> y <a>maximumBy</a>).
masRepetido4 :: Ord a => [a] -> (a, Int)

-- | 5ª definición (sin argumentos)
masRepetido5 :: Ord a => [a] -> (a, Int)

-- | <b>(prop_masRepetido xs)</b> se verifica si las definiciones de
--   masRepetido son equivalentes sobre xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_masRepetido
--   +++ OK, passed 100 tests.
--   </pre>
prop_masRepetido :: (NonEmptyList Int) -> Bool


-- | Definir la función
--   
--   <pre>
--   listaCuadrada :: Int -&gt; a -&gt; [a] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(listaCuadrada n x xs)</b> es una lista de n listas de
--   longitud n formadas con los elementos de xs completada con x, si no xs
--   no tiene suficientes elementos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; listaCuadrada 3 7 [0,3,5,2,4]
--   [[0,3,5],[2,4,7],[7,7,7]]
--   
--   &gt;&gt;&gt; listaCuadrada 3 7 [0..]
--   [[0,1,2],[3,4,5],[6,7,8]]
--   
--   &gt;&gt;&gt; listaCuadrada 2 'p' "eva"
--   ["ev","ap"]
--   
--   &gt;&gt;&gt; listaCuadrada 2 'p' ['a'..]
--   ["ab","cd"]
--   
--   &gt;&gt;&gt; listaCuadrada 1 0 ([]::[Int])
--   [[0]]
--   </pre>
module Lista_cuadrada

-- | 1ª definición (con auxiliar).
listaCuadrada :: Int -> a -> [a] -> [[a]]

-- | (grupos n xs) es la lista obtenida agrupando los elementos de xs en
--   grupos de n elementos, salvo el último que puede tener menos. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; grupos 2 [4,2,5,7,6]
--   [[4,2],[5,7],[6]]
--   
--   &gt;&gt;&gt; take 3 (grupos 3 [1..])
--   [[1,2,3],[4,5,6],[7,8,9]]
--   </pre>
grupos :: Int -> [a] -> [[a]]

-- | 2ª definición (por comprensión).
listaCuadrada2 :: Int -> a -> [a] -> [[a]]

-- | 3ª definición (por iteración).
listaCuadrada3 :: Int -> a -> [a] -> [[a]]

-- | 4ª definición (por iteración sin el último argumento).
listaCuadrada4 :: Int -> a -> [a] -> [[a]]

-- | (prop_listaCuadrada n x xs) se verifica si las definiciones de
--   listaCuadrada son equivalentes sobre n, x, xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_listaCuadrada (NonNegative 3) 7 [0,3,5,2,4]
--   True
--   
--   &gt;&gt;&gt; prop_listaCuadrada (NonNegative 3) 7 [0..]
--   True
--   </pre>
prop_listaCuadrada :: NonNegative Int -> Int -> [Int] -> Bool

-- | Comprueba la equivalencia de las definiciones de listaCuadrada.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_listaCuadrada
--   +++ OK, passed 100 tests.
--   </pre>
verifica_listaCuadrada :: IO ()


-- | Definir la función
--   
--   <pre>
--   igualesAlSiguiente :: Eq a =&gt; [a] -&gt; [a]
--   </pre>
--   
--   tal que <b>(igualesAlSiguiente xs)</b> es la lista de los elementos de
--   xs que son iguales a su siguiente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; igualesAlSiguiente [1,2,2,2,3,3,4::Int]
--   [2,2,3]
--   
--   &gt;&gt;&gt; igualesAlSiguiente [1..10::Int]
--   []
--   </pre>
module Iguales_al_siguiente

-- | 1ª definición (con zip)
igualesAlSiguiente :: Eq a => [a] -> [a]

-- | 2ª definición (por recursión)
igualesAlSiguiente2 :: Eq a => [a] -> [a]

-- | 3ª definición (con concat y comprensión)
igualesAlSiguiente3 :: Eq a => [a] -> [a]

-- | 4ª definición (con concatMap)
igualesAlSiguiente4 :: Eq a => [a] -> [a]

-- | 5ª definición (con concatMap y sin argumentos):
igualesAlSiguiente5 :: Eq a => [a] -> [a]

-- | (prop_igualesAlSiguiente xs) se verifica si todas las definiciones de
--   igualesAlsiguiente son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_igualesAlSiguiente [1,2,2,2,3,3,4]
--   True
--   
--   &gt;&gt;&gt; prop_igualesAlSiguiente [1..10]
--   True
--   </pre>
prop_igualesAlSiguiente :: [Int] -> Bool

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   verificaIgualesAlSiguiente
--   </pre>
--   
--   +++ OK, passed 100 tests.
verifica_igualesAlSiguiente :: IO ()


-- | Definir la función
--   
--   <pre>
--   zipBinario :: [a -&gt; b -&gt; c] -&gt; [a] -&gt; [b] -&gt; [c]
--   </pre>
--   
--   tal que <b>(zipBinario fs xs ys)</b> es la lista obtenida aplicando
--   cada una de las operaciones binarias de fs a los correspondientes
--   elementos de xs e ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; zipBinario [(+), (*), (^)] [2,2,2] [4,4,4]
--   [6,8,16]
--   
--   &gt;&gt;&gt; zipBinario [(+)] [2,2,2] [4,4,4]
--   [6]
--   
--   &gt;&gt;&gt; zipBinario (cycle [(+), (*)]) [1 .. 4] [2..5]
--   [3,6,7,20]
--   </pre>
module Emparejamiento_binario

-- | 1ª definición (por recursión).
zipBinario :: [a -> b -> c] -> [a] -> [b] -> [c]

-- | 2ª definición (con <a>zip</a>).
zipBinario2 :: [a -> b -> c] -> [a] -> [b] -> [c]

-- | 3ª definición (con <a>zip3</a>).
zipBinario3 :: [a -> b -> c] -> [a] -> [b] -> [c]

-- | 4ª definición (con <a>zipWith3</a>).
zipBinario4 :: [a -> b -> c] -> [a] -> [b] -> [c]

-- | Tipo de operaciones para la verificación.
newtype Operacion
O :: (Int -> Int -> Int) -> Operacion

-- | Escritura de operaciones.

-- | Generador de operaciones.
gen_operaciones :: Gen [Operacion]

-- | Comprueba la equivalencia de las definiciones de zipBinario.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_zipBinario
--   +++ OK, passed 100 tests.
--   </pre>
prop_zipBinario :: [Int] -> [Int] -> Property
instance GHC.Show.Show Emparejamiento_binario.Operacion


-- | Definir la función
--   
--   <pre>
--   minimales :: Eq a =&gt; [[a]] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(minimales xss)</b> es la lista de los elementos de xss que
--   no están contenidos en otros elementos de xss. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; minimales [[1,3],[2,3,1],[3,2,5]]
--   [[2,3,1],[3,2,5]]
--   
--   &gt;&gt;&gt; minimales [[1,3],[2,3,1],[3,2,5],[3,1]]
--   [[2,3,1],[3,2,5]]
--   </pre>
module ElementosMinimales

-- | Definición
minimales :: Eq a => [[a]] -> [[a]]

-- | (subconjuntoPropio xs ys) se verifica si xs es un subconjunto propio
--   de ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; subconjuntoPropio [1,3] [3,1,3]
--   False
--   
--   &gt;&gt;&gt; subconjuntoPropio [1,3,1] [3,1,2]
--   True
--   </pre>
subconjuntoPropio :: Eq a => [a] -> [a] -> Bool


-- | El problema de la bandera tricolor consiste en lo siguiente: Dada un
--   lista de objetos xs que pueden ser rojos, amarillos o morados, se pide
--   devolver una lista ys que contiene los elementos de xs, primero los
--   rojos, luego los amarillos y por último los morados.
--   
--   Definir el tipo de dato Color para representar los colores con los
--   constructores R, A y M correspondientes al rojo, azul y morado y la
--   función
--   
--   <pre>
--   banderaTricolor :: [Color] -&gt; [Color]
--   </pre>
--   
--   tal que <b>(banderaTricolor xs)</b> es la bandera tricolor formada con
--   los elementos de xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; banderaTricolor [M,R,A,A,R,R,A,M,M]
--   [R,R,R,A,A,A,M,M,M]
--   
--   &gt;&gt;&gt; banderaTricolor [M,R,A,R,R,A]
--   [R,R,R,A,A,M]
--   </pre>
module Bandera_tricolor

-- | Definición de los colores
data Color
R :: Color
A :: Color
M :: Color

-- | 1ª definición
banderaTricolor :: [Color] -> [Color]

-- | 2ª definición (por comprensión):
banderaTricolor2 :: [Color] -> [Color]

-- | 3ª definición (por comprensión y concat):
banderaTricolor3 :: [Color] -> [Color]

-- | 4ª definición (por recursión):
banderaTricolor4 :: [Color] -> [Color]

-- | 5ª definición (por recursión):
banderaTricolor5 :: [Color] -> [Color]

-- | (prop_banderaTricolor xs) se verifica si todas las definiciones de
--   banderaTricolor son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_banderaTricolor [M,R,A,A,R,R,A,M,M]
--   True
--   
--   &gt;&gt;&gt; prop_banderaTricolor [M,R,A,R,R,A]
--   True
--   </pre>
prop_banderaTricolor :: [Color] -> Bool

-- | Incluye el tipo Color en Arbitrary

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verifica_banderaTricolor
--   +++ OK, passed 100 tests.
--   </pre>
verifica_banderaTricolor :: IO ()
instance GHC.Enum.Enum Bandera_tricolor.Color
instance GHC.Classes.Ord Bandera_tricolor.Color
instance GHC.Classes.Eq Bandera_tricolor.Color
instance GHC.Show.Show Bandera_tricolor.Color
instance Test.QuickCheck.Arbitrary.Arbitrary Bandera_tricolor.Color


-- | Una palabra es una anagrama de otra si se puede obtener permutando sus
--   letras. Por ejemplo, "mora" y "roma" son anagramas de "amor".
--   
--   Definir la función
--   
--   <pre>
--   anagramas :: String -&gt; [String] -&gt; [String]
--   </pre>
--   
--   tal que (anagramas x ys) es la lista de los elementos de ys que son
--   anagramas de x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; anagramas "amor" ["Roma","mola","loma","moRa", "rama"]
--   ["Roma","moRa"]
--   
--   &gt;&gt;&gt; anagramas "rama" ["aMar","amaRa","roMa","marr","aRma"]
--   ["aMar","aRma"]
--   </pre>
module Anagramas

-- | 1ª definición (por recursión):
anagramas :: String -> [String] -> [String]

-- | (sonAnagramas xs ys) se verifica si xs e ys son anagramas. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sonAnagramas "amor" "Roma"
--   True
--   
--   &gt;&gt;&gt; sonAnagramas "amor" "mola"
--   False
--   </pre>
sonAnagramas :: String -> String -> Bool

-- | 2ª definición de sonAnagramas
sonAnagramas2 :: String -> String -> Bool

-- | 3ª definición de sonAnagramas (con on)
sonAnagramas3 :: String -> String -> Bool

-- | Comprobación de la equivalencia de las definiciones de anagramas.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_sonAnagramas
--   True
--   </pre>
verifica_sonAnagramas :: Bool

-- | 2ª definición (por comprensión)
anagramas2 :: String -> [String] -> [String]

-- | 3ª definición (con filter y sin el 2ª argumento)
anagramas3 :: String -> [String] -> [String]

-- | 4ª definición (sin sonAnagramas ni el 2º argumento)
anagramas4 :: String -> [String] -> [String]

-- | Comprobación de la equivalencia de las definiciones de anagramas.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_anagramas
--   True
--   </pre>
verifica_anagramas :: Bool


-- | Las matrices enteras se pueden representar mediante tablas con índices
--   enteros:
--   
--   <pre>
--   type Matriz = Array (Int,Int) Int
--   </pre>
--   
--   Definir la función
--   
--   <pre>
--   ampliaColumnas :: Matriz -&gt; Matriz -&gt; Matriz
--   </pre>
--   
--   tal que <b>(ampliaColumnas p q)</b> es la matriz construida añadiendo
--   las columnas de la matriz q a continuación de las de p (se supone que
--   tienen el mismo número de filas). Por ejemplo, si p y q representan
--   las dos primeras matrices, entonces (ampliaColumnas p q) es la tercera
--   
--   <pre>
--   |0 1|    |4 5 6|    |0 1 4 5 6| 
--   |2 3|    |7 8 9|    |2 3 7 8 9|
--   </pre>
--   
--   En Haskell,
--   
--   <pre>
--   &gt;&gt;&gt; let p = listArray ((1,1),(2,2)) [0..3]
--   
--   &gt;&gt;&gt; let q = listArray ((1,1),(2,3)) [4..9]
--   
--   &gt;&gt;&gt; elems (ampliaColumnas p q)
--   [0,1,4,5,6,2,3,7,8,9]
--   
--   &gt;&gt;&gt; bounds (ampliaColumnas p q)
--   ((1,1),(2,5))
--   </pre>
module Amplia_columnas

-- | Tipo de las matrices.
type Matriz = Array (Int, Int) Int

-- | Definición.
ampliaColumnas :: Matriz -> Matriz -> Matriz


-- | Definir la función
--   
--   <pre>
--   alfabetoDesde :: Char -&gt; String
--   </pre>
--   
--   tal que <b>(alfabetoDesde c)</b> es el alfabeto, en minúscula,
--   comenzando en el carácter c, si c es una letra minúscula y comenzando
--   en <tt>a</tt>, en caso contrario. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; alfabetoDesde 'e'
--   "efghijklmnopqrstuvwxyzabcd"
--   
--   &gt;&gt;&gt; alfabetoDesde 'a'
--   "abcdefghijklmnopqrstuvwxyz"
--   
--   &gt;&gt;&gt; alfabetoDesde '7'
--   "abcdefghijklmnopqrstuvwxyz"
--   
--   &gt;&gt;&gt; alfabetoDesde '{'
--   "abcdefghijklmnopqrstuvwxyz"
--   
--   &gt;&gt;&gt; alfabetoDesde 'B'
--   "abcdefghijklmnopqrstuvwxyz"
--   </pre>
module Alfabeto_desde

-- | 1ª definición (con <a>dropWhile</a> y <a>takeWhile</a>).
alfabetoDesde :: Char -> String

-- | 2ª definición (con <a>span</a>).
alfabetoDesde2 :: Char -> String

-- | 3ª definición (con <a>break</a>).
alfabetoDesde3 :: Char -> String

-- | 4ª definición (sin argumentos):
alfabetoDesde4 :: Char -> String

-- | 5ª definición (sin argumentos).
alfabetoDesde5 :: Char -> String

-- | 6ª definición (por comprensión).
alfabetoDesde6 :: Char -> String

-- | 7ª definición (por comprensión con <a>isAsciiLower</a>).
alfabetoDesde7 :: Char -> String

-- | (prop_alfabetoDesde c) se verifica si las definiciones de
--   alfabetoDesde sobre c. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    and [ prop_alfabetoDesde 'e'
--        , prop_alfabetoDesde 'a'
--        , prop_alfabetoDesde '7'
--        , prop_alfabetoDesde '{'
--        , prop_alfabetoDesde 'B'
--        ]
--   :}
--   True
--   </pre>
prop_alfabetoDesde :: Char -> Bool

-- | Comprueba la equivalencia de las definiciones.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_alfabetoDesde
--   +++ OK, passed 100 tests.
--   </pre>
verifica_alfabetoDesde :: IO ()
