-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Problemas de Exercitium (curso 2013-14)
--   
--   Ejercicios de programación funcional con Haskell propuestos en el blog
--   Exercitium durante el curso 2013-14.
@package Exercitium1314
@version 0.1.0.0

module Suma_si_todos_justos
sumaSiTodosJustos :: (Num a, Eq a) => [Maybe a] -> Maybe a
todosJustos :: Eq a => [Maybe a] -> Bool
todosJustos2 :: Eq a => [Maybe a] -> Bool
sumaSiTodosJustos2 :: (Num a, Eq a) => [Maybe a] -> Maybe a
sumaSiTodosJustos3 :: (Num a, Eq a) => [Maybe a] -> Maybe a
sumaSiTodosJustos4 :: (Num a, Eq a) => [Maybe a] -> Maybe a
sumaSiTodosJustos5 :: (Num a, Eq a) => [Maybe a] -> Maybe a
sumaSiTodosJustos6 :: (Num a, Eq a) => [Maybe a] -> Maybe a


-- | Definir la función
--   
--   <pre>
--   primosEquidistantes :: Integer -&gt; [(Integer,Integer)]
--   </pre>
--   
--   tal que <b>(primosEquidistantes k)</b> es la lista de los pares de
--   primos cuya diferencia es k. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; take 3 (primosEquidistantes 2)
--   [(3,5),(5,7),(11,13)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 4)
--   [(7,11),(13,17),(19,23)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 6)
--   [(23,29),(31,37),(47,53)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 8)
--   [(89,97),(359,367),(389,397)]
--   </pre>
module Primos_equidistantes

-- | 1ª definición
primosEquidistantes :: Integer -> [(Integer, Integer)]

-- | 2ª definición
--   
--   <pre>
--   &gt;&gt;&gt; take 20 (primosEquidistantes2 2) == take 20 (primosEquidistantes 2)
--   True
--   
--   &gt;&gt;&gt; take 20 (primosEquidistantes2 4) == take 20 (primosEquidistantes 4)
--   True
--   </pre>
primosEquidistantes2 :: Integer -> [(Integer, Integer)]


-- | Definir las funciones
--   
--   <pre>
--   primosConsecutivosConMediaCapicua :: [(Int,Int,Int)]
--   nPrimosConsecutivosConMediaCapicua :: Int -&gt; Int
--   </pre>
--   
--   tales que
--   
--   <ul>
--   <li><b>primosConsecutivosConMediaCapicua</b> es la lista de las ternas
--   (x,y,z) tales que x e y son primos consecutivos cuya media, z, es
--   capicúa. Por ejemplo,</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 primosConsecutivosConMediaCapicua
--   [(3,5,4),(5,7,6),(7,11,9),(97,101,99),(109,113,111)]
--   </pre>
--   
--   <ul>
--   <li><b>(nPrimosConsecutivosConMediaCapicua n)</b> es el número de
--   ternas de primos consecutivos con media capicua que son menores que n.
--   Por ejemplo,</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; nPrimosConsecutivosConMediaCapicua 2014
--   20
--   </pre>
module Primos_consecutivos_con_media_capicua
primosConsecutivosConMediaCapicua :: [(Int, Int, Int)]
nPrimosConsecutivosConMediaCapicua :: Int -> Int

-- | (verifica_primosConsecutivosConMediaCapicua n =) se verifica si las
--   definiciones de primosConsecutivosConMediaCapicua son equivalentes
--   para los n primeros elementos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; verifica_primosConsecutivosConMediaCapicua 20
--   True
--   </pre>
verifica_primosConsecutivosConMediaCapicua :: Int -> Bool


-- | Definir la función
--   
--   <pre>
--   ordenadosPorMaximo :: Ord a =&gt; [[a]] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(ordenadosPorMaximo xss)</b> es la lista de los elementos
--   de xss ordenada por sus máximos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; ordenadosPorMaximo [[3,2],[6,7,5],[1,4]]
--   [[3,2],[1,4],[6,7,5]]
--   
--   &gt;&gt;&gt; ordenadosPorMaximo ["este","es","el","primero"]
--   ["el","primero","es","este"]
--   </pre>
module Ordenados_por_maximo
ordenadosPorMaximo :: Ord a => [[a]] -> [[a]]

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verificaOrdenadosPorMaximo
--   +++ OK, passed 100 tests.
--   </pre>
verificaOrdenadosPorMaximo :: IO ()

module Matriz_Toeplitz
ej1 :: Array (Int, Int) Int
ej2 :: Array (Int, Int) Int
esToeplitz :: Eq a => Array (Int, Int) a -> Bool


-- | El Mastermind es un juego que consiste en deducir un código numérico
--   formado por una lista de números distintos. Cada vez que se empieza un
--   partido, el programa debe elegir un código, que será lo que el jugador
--   debe adivinar en la menor cantidad de intentos posibles. Cada intento
--   consiste en una propuesta de un código posible que propone el jugador,
--   y una respuesta del programa. Las respuestas le darán pistas al
--   jugador para que pueda deducir el código.
--   
--   Estas pistas indican cuán cerca estuvo el número propuesto de la
--   solución a través de dos valores: la cantidad de aciertos es la
--   cantidad de dígitos que propuso el jugador que también están en el
--   código en la misma posición. La cantidad de coincidencias es la
--   cantidad de digitos que propuso el jugador que también están en el
--   código pero en una posición distinta.
--   
--   Por ejemplo, si el código que eligió el programa es el [2,6,0,7], y el
--   jugador propone el [1,4,0,6], el programa le debe responder un acierto
--   (el 0, que está en el código original en el mismo lugar, el tercero),
--   y una coincidencia (el 6, que también está en el código original, pero
--   en la segunda posición, no en el cuarto como fue propuesto). Si el
--   jugador hubiera propuesto el [3,5,9,1], habría obtenido como respuesta
--   ningún acierto y ninguna coincidencia, ya que no hay números en común
--   con el código original, y si se obtienen cuatro aciertos es porque el
--   jugador adivinó el código y ganó el juego.
--   
--   Definir la función
--   
--   <pre>
--   mastermind :: [Int] -&gt; [Int] -&gt; (Int,Int)
--   </pre>
--   
--   tal que <b>(mastermind xs ys)</b> es el par formado por los números de
--   aciertos y de coincidencias entre xs e ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; mastermind [2,6,0,7] [1,4,0,6]
--   (1,1)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [3,5,9,1]
--   (0,0)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [1,6,0,4]
--   (2,0)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [2,6,0,7]
--   (4,0)
--   </pre>
module Mastermind
mastermind :: [Int] -> [Int] -> (Int, Int)

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verifica_mastermind
--   +++ OK, passed 100 tests.
--   </pre>
verifica_mastermind :: IO ()


-- | Definir la función
--   
--   <pre>
--   igualesAlSiguiente :: Eq a =&gt; [a] -&gt; [a]
--   </pre>
--   
--   tal que <b>(igualesAlSiguiente xs)</b> es la lista de los elementos de
--   xs que son iguales a su siguiente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; igualesAlSiguiente [1,2,2,2,3,3,4::Int]
--   [2,2,3]
--   
--   &gt;&gt;&gt; igualesAlSiguiente [1..10::Int]
--   []
--   </pre>
module Iguales_al_siguiente
igualesAlSiguiente :: Eq a => [a] -> [a]

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verificaIgualesAlSiguiente
--   +++ OK, passed 100 tests.
--   </pre>
verificaIgualesAlSiguiente :: IO ()


-- | Definir la función
--   
--   <pre>
--   minimales :: Eq a =&gt; [[a]] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(minimales xss)</b> es la lista de los elementos de xss que
--   no están contenidos en otros elementos de xss. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; minimales [[1,3],[2,3,1],[3,2,5]]
--   [[2,3,1],[3,2,5]]
--   
--   &gt;&gt;&gt; minimales [[1,3],[2,3,1],[3,2,5],[3,1]]
--   [[2,3,1],[3,2,5]]
--   </pre>
module ElementosMinimales
minimales :: Eq a => [[a]] -> [[a]]


-- | El problema de la bandera tricolor consiste en lo siguiente: Dada un
--   lista de objetos xs que pueden ser rojos, amarillos o morados, se pide
--   devolver una lista ys que contiene los elementos de xs, primero los
--   rojos, luego los amarillos y por último los morados.
--   
--   Definir el tipo de dato Color para representar los colores con los
--   constructores R, A y M correspondientes al rojo, azul y morado y la
--   función
--   
--   <pre>
--   banderaTricolor :: [Color] -&gt; [Color]
--   </pre>
--   
--   tal que <b>(banderaTricolor xs)</b> es la bandera tricolor formada con
--   los elementos de xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; banderaTricolor [M,R,A,A,R,R,A,M,M]
--   [R,R,R,A,A,A,M,M,M]
--   
--   &gt;&gt;&gt; banderaTricolor [M,R,A,R,R,A]
--   [R,R,R,A,A,M]
--   </pre>
module Bandera_tricolor
data Color
banderaTricolor :: [Color] -> [Color]

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verifica_banderaTricolor
--   +++ OK, passed 100 tests.
--   </pre>
verifica_banderaTricolor :: IO ()
instance GHC.Enum.Enum Bandera_tricolor.Color
instance GHC.Classes.Ord Bandera_tricolor.Color
instance GHC.Classes.Eq Bandera_tricolor.Color
instance GHC.Show.Show Bandera_tricolor.Color
instance Test.QuickCheck.Arbitrary.Arbitrary Bandera_tricolor.Color


-- | Una palabra es una anagrama de otra si se puede obtener permutando sus
--   letras. Por ejemplo, "mora" y "roma" son anagramas de "amor".
--   
--   Definir la función
--   
--   <pre>
--   anagramas :: String -&gt; [String] -&gt; [String]
--   </pre>
--   
--   tal que (anagramas x ys) es la lista de los elementos de ys que son
--   anagramas de x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; anagramas "amor" ["Roma","mola","loma","moRa", "rama"]
--   ["Roma","moRa"]
--   
--   &gt;&gt;&gt; anagramas "rama" ["aMar","amaRa","roMa","marr","aRma"]
--   ["aMar","aRma"]
--   </pre>
module Anagramas

-- | 1ª definición (por recursión):
anagramas :: String -> [String] -> [String]

-- | 2ª definición (por comprensión)
--   
--   <pre>
--   &gt;&gt;&gt; anagramas2 "amor" ["Roma","mola","loma","moRa", "rama"]
--   ["Roma","moRa"]
--   
--   &gt;&gt;&gt; anagramas2 "rama" ["aMar","amaRa","roMa","marr","aRma"]
--   ["aMar","aRma"]
--   </pre>
anagramas2 :: String -> [String] -> [String]

-- | 3ª definición (con filter y sin el 2ª argumento)
--   
--   <pre>
--   &gt;&gt;&gt; anagramas3 "amor" ["Roma","mola","loma","moRa", "rama"]
--   ["Roma","moRa"]
--   
--   &gt;&gt;&gt; anagramas3 "rama" ["aMar","amaRa","roMa","marr","aRma"]
--   ["aMar","aRma"]
--   </pre>
anagramas3 :: String -> [String] -> [String]

-- | 4ª definición (sin sonAnagramas ni el 2º argumento)
--   
--   <pre>
--   &gt;&gt;&gt; anagramas4 "amor" ["Roma","mola","loma","moRa", "rama"]
--   ["Roma","moRa"]
--   
--   &gt;&gt;&gt; anagramas4 "rama" ["aMar","amaRa","roMa","marr","aRma"]
--   ["aMar","aRma"]
--   </pre>
anagramas4 :: String -> [String] -> [String]

-- | (sonAnagramas xs ys) se verifica si xs e ys son anagramas. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sonAnagramas "amor" "Roma"
--   True
--   
--   &gt;&gt;&gt; sonAnagramas "amor" "mola"
--   False
--   </pre>
sonAnagramas :: String -> String -> Bool

-- | 2ª definición de sonAnagramas
--   
--   <pre>
--   &gt;&gt;&gt; sonAnagramas2 "amor" "Roma"
--   True
--   
--   &gt;&gt;&gt; sonAnagramas2 "amor" "mola"
--   False
--   </pre>
sonAnagramas2 :: String -> String -> Bool

-- | 3ª definición de sonAnagramas (con on)
--   
--   <pre>
--   &gt;&gt;&gt; sonAnagramas3 "amor" "Roma"
--   True
--   
--   &gt;&gt;&gt; sonAnagramas3 "amor" "mola"
--   False
--   </pre>
sonAnagramas3 :: String -> String -> Bool
