-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Problemas de Exercitium (Volumen 1)
--   
--   Durante el curso 2013-14 se creó el blog <a>Exercitium</a> como
--   complemento del curso de <a>Informática</a> de 1º del Grado de
--   Matemáticas de la Universidad de Sevilla.
--   
--   El objetivo de <a>Exercitium</a> es plantear diariamente un problema
--   para que los alumnos pudieran practicar y escribir distintas
--   soluciones en los comentarios.
--   
--   Este repositorio es una recopilación de los ejercicios propuestos en
--   <a>Exercitium</a> durante el curso 2013-14.
@package Exercitium1
@version 0.1.0.0


-- | Definir la función
--   
--   <pre>
--   sumaSiTodosJustos :: (Num a, Eq a) =&gt; [Maybe a] -&gt; Maybe a
--   </pre>
--   
--   tal que <b>(sumaSiTodosJustos xs)</b> es justo la suma de todos los
--   elementos de xs si todos son justos (es decir, si Nothing no pertenece
--   a xs) y Nothing en caso contrario. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sumaSiTodosJustos [Just 2, Just 5]
--   Just 7
--   
--   &gt;&gt;&gt; sumaSiTodosJustos [Just 2, Just 5, Nothing]
--   Nothing
--   </pre>
module Suma_si_todos_justos

-- | 1ª definición
sumaSiTodosJustos :: (Num a, Eq a) => [Maybe a] -> Maybe a

-- | Verificación
verifica_sumaSiTodosJustos :: IO ()


-- | Definir la función
--   
--   <pre>
--   primosEquidistantes :: Integer -&gt; [(Integer,Integer)]
--   </pre>
--   
--   tal que <b>(primosEquidistantes k)</b> es la lista de los pares de
--   primos cuya diferencia es k. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; take 3 (primosEquidistantes 2)
--   [(3,5),(5,7),(11,13)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 4)
--   [(7,11),(13,17),(19,23)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 6)
--   [(23,29),(31,37),(47,53)]
--   
--   &gt;&gt;&gt; take 3 (primosEquidistantes 8)
--   [(89,97),(359,367),(389,397)]
--   </pre>
module Primos_equidistantes

-- | 1ª definición
primosEquidistantes :: Integer -> [(Integer, Integer)]

-- | 2ª definición
--   
--   <pre>
--   &gt;&gt;&gt; take 20 (primosEquidistantes2 2) == take 20 (primosEquidistantes 2)
--   True
--   
--   &gt;&gt;&gt; take 20 (primosEquidistantes2 4) == take 20 (primosEquidistantes 4)
--   True
--   </pre>
primosEquidistantes2 :: Integer -> [(Integer, Integer)]


-- | Definir las funciones
--   
--   <pre>
--   primosConsecutivosConMediaCapicua :: [(Int,Int,Int)]
--   nPrimosConsecutivosConMediaCapicua :: Int -&gt; Int
--   </pre>
--   
--   tales que
--   
--   <ul>
--   <li><b>primosConsecutivosConMediaCapicua</b> es la lista de las ternas
--   (x,y,z) tales que x e y son primos consecutivos cuya media, z, es
--   capicúa. Por ejemplo,</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; take 5 primosConsecutivosConMediaCapicua
--   [(3,5,4),(5,7,6),(7,11,9),(97,101,99),(109,113,111)]
--   </pre>
--   
--   <ul>
--   <li><b>(nPrimosConsecutivosConMediaCapicua n)</b> es el número de
--   ternas de primos consecutivos con media capicua que son menores que n.
--   Por ejemplo,</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; nPrimosConsecutivosConMediaCapicua 2014
--   20
--   </pre>
module Primos_consecutivos_con_media_capicua

-- | 1ª definición (definiendo los primos)
primosConsecutivosConMediaCapicua :: [(Int, Int, Int)]

-- | (primo x) se verifica si x es primo. Por ejemplo, &gt;&gt;&gt; primo 7
--   True &gt;&gt;&gt; primo 8 False
primo :: Int -> Bool

-- | primos es la lista de los números primos mayores que 2. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; take 10 primos
--   [3,5,7,11,13,17,19,23,29,31]
--   </pre>
primos :: [Int]

-- | (capicua x) se verifica si x es capicúa. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; capicua 32723
--   True
--   
--   &gt;&gt;&gt; capicua 32732
--   False
--   </pre>
capicua :: Int -> Bool

-- | 2ª definición (con primes)
primosConsecutivosConMediaCapicua2 :: [(Int, Int, Int)]

-- | (verifica_primosConsecutivosConMediaCapicua n =) se verifica si las
--   definiciones de primosConsecutivosConMediaCapicua son equivalentes
--   para los n primeros elementos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; verifica_primosConsecutivosConMediaCapicua 20
--   True
--   </pre>
verifica_primosConsecutivosConMediaCapicua :: Int -> Bool


-- | Definir la función
--   
--   <pre>
--   ordenadosPorMaximo :: Ord a =&gt; [[a]] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(ordenadosPorMaximo xss)</b> es la lista de los elementos
--   de xss ordenada por sus máximos. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; ordenadosPorMaximo [[3,2],[6,7,5],[1,4]]
--   [[3,2],[1,4],[6,7,5]]
--   
--   &gt;&gt;&gt; ordenadosPorMaximo ["este","es","el","primero"]
--   ["el","primero","es","este"]
--   </pre>
module Ordenados_por_maximo

-- | 1ª definición
ordenadosPorMaximo :: Ord a => [[a]] -> [[a]]

-- | 2ª definición
ordenadosPorMaximo2 :: Ord a => [[a]] -> [[a]]

-- | (prop_ordenadosPorMaximo xs) se verifica si todas las definiciones de
--   ordenadosPorMaximo son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_ordenadosPorMaximo [[3,2],[6,7,5],[1,4]]
--   True
--   
--   &gt;&gt;&gt; prop_ordenadosPorMaximo ["este","es","el","primero"]
--   True
--   </pre>
prop_ordenadosPorMaximo :: Ord a => [[a]] -> Bool

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verificaOrdenadosPorMaximo
--   +++ OK, passed 100 tests.
--   </pre>
verificaOrdenadosPorMaximo :: IO ()


-- | Una matriz de Toeplitz es una matriz cuadrada que es constante a lo
--   largo de las diagonales paralelas a la diagonal principal. Por
--   ejemplo,
--   
--   <pre>
--   |2 5 1 6|       |2 5 1 6|          
--   |4 2 5 1|       |4 2 6 1|
--   |7 4 2 5|       |7 4 2 5|
--   |9 7 4 2|       |9 7 4 2|
--   </pre>
--   
--   la primera es una matriz de Toeplitz y la segunda no lo es.
--   
--   Las anteriores matrices se pueden definir por
--   
--   <pre>
--   ej1, ej2 :: Array (Int,Int) Int
--   ej1 = listArray ((1,1),(4,4)) [2,5,1,6,4,2,5,1,7,4,2,5,9,7,4,2]
--   ej2 = listArray ((1,1),(4,4)) [2,5,1,6,4,2,6,1,7,4,2,5,9,7,4,2]
--   </pre>
--   
--   Definir la función
--   
--   <pre>
--   esToeplitz :: Eq a =&gt; Array (Int,Int) a -&gt; Bool
--   </pre>
--   
--   tal que <b>(esToeplitz p)</b> se verifica si la matriz p es de
--   Toeplitz. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esToeplitz ej1
--   True
--   
--   &gt;&gt;&gt; esToeplitz ej2
--   False
--   </pre>
module Matriz_Toeplitz

-- | Ejemplos de matrices
ej1 :: Array (Int, Int) Int

-- | Ejemplos de matrices
ej2 :: Array (Int, Int) Int

-- | Definición
esToeplitz :: Eq a => Array (Int, Int) a -> Bool


-- | El Mastermind es un juego que consiste en deducir un código numérico
--   formado por una lista de números distintos. Cada vez que se empieza un
--   partido, el programa debe elegir un código, que será lo que el jugador
--   debe adivinar en la menor cantidad de intentos posibles. Cada intento
--   consiste en una propuesta de un código posible que propone el jugador,
--   y una respuesta del programa. Las respuestas le darán pistas al
--   jugador para que pueda deducir el código.
--   
--   Estas pistas indican cuán cerca estuvo el número propuesto de la
--   solución a través de dos valores: la cantidad de aciertos es la
--   cantidad de dígitos que propuso el jugador que también están en el
--   código en la misma posición. La cantidad de coincidencias es la
--   cantidad de digitos que propuso el jugador que también están en el
--   código pero en una posición distinta.
--   
--   Por ejemplo, si el código que eligió el programa es el [2,6,0,7], y el
--   jugador propone el [1,4,0,6], el programa le debe responder un acierto
--   (el 0, que está en el código original en el mismo lugar, el tercero),
--   y una coincidencia (el 6, que también está en el código original, pero
--   en la segunda posición, no en el cuarto como fue propuesto). Si el
--   jugador hubiera propuesto el [3,5,9,1], habría obtenido como respuesta
--   ningún acierto y ninguna coincidencia, ya que no hay números en común
--   con el código original, y si se obtienen cuatro aciertos es porque el
--   jugador adivinó el código y ganó el juego.
--   
--   Definir la función
--   
--   <pre>
--   mastermind :: [Int] -&gt; [Int] -&gt; (Int,Int)
--   </pre>
--   
--   tal que <b>(mastermind xs ys)</b> es el par formado por los números de
--   aciertos y de coincidencias entre xs e ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; mastermind [2,6,0,7] [1,4,0,6]
--   (1,1)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [3,5,9,1]
--   (0,0)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [1,6,0,4]
--   (2,0)
--   
--   &gt;&gt;&gt; mastermind [2,6,0,7] [2,6,0,7]
--   (4,0)
--   </pre>
module Mastermind

-- | 1ª definición
mastermind :: [Int] -> [Int] -> (Int, Int)

-- | (aciertos xs ys) es la lista de aciertos entre xs e ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; aciertos [2,6,0,7] [1,4,0,6]
--   [0]
--   </pre>
aciertos :: Eq a => [a] -> [a] -> [a]

-- | (coincidencia xs ys) es la lista de coincidencias entre xs e ys. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; coincidencias [2,6,0,7] [1,4,0,6]
--   [6]
--   </pre>
coincidencias :: Eq a => [a] -> [a] -> [a]

-- | 2ª definición (por recursión):
mastermind2 :: [Int] -> [Int] -> (Int, Int)

-- | 3ª definición:
mastermind3 :: [Int] -> [Int] -> (Int, Int)

-- | (prop_mastermind xs) se verifica si todas las definiciones de
--   mastermind son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [1,4,0,6]
--   True
--   
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [3,5,9,1]
--   True
--   
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [1,6,0,4]
--   True
--   
--   &gt;&gt;&gt; prop_mastermind [2,6,0,7] [2,6,0,7]
--   True
--   </pre>
prop_mastermind :: [Int] -> [Int] -> Bool

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verifica_mastermind
--   +++ OK, passed 100 tests.
--   </pre>
verifica_mastermind :: IO ()


-- | Definir la función
--   
--   <pre>
--   igualesAlSiguiente :: Eq a =&gt; [a] -&gt; [a]
--   </pre>
--   
--   tal que <b>(igualesAlSiguiente xs)</b> es la lista de los elementos de
--   xs que son iguales a su siguiente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; igualesAlSiguiente [1,2,2,2,3,3,4::Int]
--   [2,2,3]
--   
--   &gt;&gt;&gt; igualesAlSiguiente [1..10::Int]
--   []
--   </pre>
module Iguales_al_siguiente

-- | 1ª definición (con zip)
igualesAlSiguiente :: Eq a => [a] -> [a]

-- | 2ª definición (por recursión)
igualesAlSiguiente2 :: Eq a => [a] -> [a]

-- | 3ª definición (con concat y comprensión)
igualesAlSiguiente3 :: Eq a => [a] -> [a]

-- | 4ª definición (con concatMap)
igualesAlSiguiente4 :: Eq a => [a] -> [a]

-- | 5ª definición (con concatMap y sin argumentos):
igualesAlSiguiente5 :: Eq a => [a] -> [a]

-- | (prop_igualesAlSiguiente xs) se verifica si todas las definiciones de
--   igualesAlsiguiente son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_igualesAlSiguiente [1,2,2,2,3,3,4]
--   True
--   
--   &gt;&gt;&gt; prop_igualesAlSiguiente [1..10]
--   True
--   </pre>
prop_igualesAlSiguiente :: [Int] -> Bool

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   verificaIgualesAlSiguiente
--   </pre>
--   
--   +++ OK, passed 100 tests.
verifica_igualesAlSiguiente :: IO ()


-- | Definir la función
--   
--   <pre>
--   minimales :: Eq a =&gt; [[a]] -&gt; [[a]]
--   </pre>
--   
--   tal que <b>(minimales xss)</b> es la lista de los elementos de xss que
--   no están contenidos en otros elementos de xss. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; minimales [[1,3],[2,3,1],[3,2,5]]
--   [[2,3,1],[3,2,5]]
--   
--   &gt;&gt;&gt; minimales [[1,3],[2,3,1],[3,2,5],[3,1]]
--   [[2,3,1],[3,2,5]]
--   </pre>
module ElementosMinimales

-- | Definición
minimales :: Eq a => [[a]] -> [[a]]

-- | (subconjuntoPropio xs ys) se verifica si xs es un subconjunto propio
--   de ys. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; subconjuntoPropio [1,3] [3,1,3]
--   False
--   
--   &gt;&gt;&gt; subconjuntoPropio [1,3,1] [3,1,2]
--   True
--   </pre>
subconjuntoPropio :: Eq a => [a] -> [a] -> Bool


-- | El problema de la bandera tricolor consiste en lo siguiente: Dada un
--   lista de objetos xs que pueden ser rojos, amarillos o morados, se pide
--   devolver una lista ys que contiene los elementos de xs, primero los
--   rojos, luego los amarillos y por último los morados.
--   
--   Definir el tipo de dato Color para representar los colores con los
--   constructores R, A y M correspondientes al rojo, azul y morado y la
--   función
--   
--   <pre>
--   banderaTricolor :: [Color] -&gt; [Color]
--   </pre>
--   
--   tal que <b>(banderaTricolor xs)</b> es la bandera tricolor formada con
--   los elementos de xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; banderaTricolor [M,R,A,A,R,R,A,M,M]
--   [R,R,R,A,A,A,M,M,M]
--   
--   &gt;&gt;&gt; banderaTricolor [M,R,A,R,R,A]
--   [R,R,R,A,A,M]
--   </pre>
module Bandera_tricolor

-- | Definición de los colores
data Color
R :: Color
A :: Color
M :: Color

-- | 1ª definición
banderaTricolor :: [Color] -> [Color]

-- | 2ª definición (por comprensión):
banderaTricolor2 :: [Color] -> [Color]

-- | 3ª definición (por comprensión y concat):
banderaTricolor3 :: [Color] -> [Color]

-- | 4ª definición (por recursión):
banderaTricolor4 :: [Color] -> [Color]

-- | 5ª definición (por recursión):
banderaTricolor5 :: [Color] -> [Color]

-- | (prop_banderaTricolor xs) se verifica si todas las definiciones de
--   banderaTricolor son equivalentes para xs. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; prop_banderaTricolor [M,R,A,A,R,R,A,M,M]
--   True
--   
--   &gt;&gt;&gt; prop_banderaTricolor [M,R,A,R,R,A]
--   True
--   </pre>
prop_banderaTricolor :: [Color] -> Bool

-- | Incluye el tipo Color en Arbitrary

-- | Comprueba la equivalencia de las definiciones
--   
--   <pre>
--   &gt;&gt;&gt; verifica_banderaTricolor
--   +++ OK, passed 100 tests.
--   </pre>
verifica_banderaTricolor :: IO ()
instance GHC.Enum.Enum Bandera_tricolor.Color
instance GHC.Classes.Ord Bandera_tricolor.Color
instance GHC.Classes.Eq Bandera_tricolor.Color
instance GHC.Show.Show Bandera_tricolor.Color
instance Test.QuickCheck.Arbitrary.Arbitrary Bandera_tricolor.Color


-- | Una palabra es una anagrama de otra si se puede obtener permutando sus
--   letras. Por ejemplo, "mora" y "roma" son anagramas de "amor".
--   
--   Definir la función
--   
--   <pre>
--   anagramas :: String -&gt; [String] -&gt; [String]
--   </pre>
--   
--   tal que (anagramas x ys) es la lista de los elementos de ys que son
--   anagramas de x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; anagramas "amor" ["Roma","mola","loma","moRa", "rama"]
--   ["Roma","moRa"]
--   
--   &gt;&gt;&gt; anagramas "rama" ["aMar","amaRa","roMa","marr","aRma"]
--   ["aMar","aRma"]
--   </pre>
module Anagramas

-- | 1ª definición (por recursión):
anagramas :: String -> [String] -> [String]

-- | (sonAnagramas xs ys) se verifica si xs e ys son anagramas. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sonAnagramas "amor" "Roma"
--   True
--   
--   &gt;&gt;&gt; sonAnagramas "amor" "mola"
--   False
--   </pre>
sonAnagramas :: String -> String -> Bool

-- | 2ª definición de sonAnagramas
sonAnagramas2 :: String -> String -> Bool

-- | 3ª definición de sonAnagramas (con on)
sonAnagramas3 :: String -> String -> Bool

-- | Comprobación de la equivalencia de las definiciones de anagramas.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_sonAnagramas
--   True
--   </pre>
verifica_sonAnagramas :: Bool

-- | 2ª definición (por comprensión)
anagramas2 :: String -> [String] -> [String]

-- | 3ª definición (con filter y sin el 2ª argumento)
anagramas3 :: String -> [String] -> [String]

-- | 4ª definición (sin sonAnagramas ni el 2º argumento)
anagramas4 :: String -> [String] -> [String]

-- | Comprobación de la equivalencia de las definiciones de anagramas.
--   
--   <pre>
--   &gt;&gt;&gt; verifica_anagramas
--   True
--   </pre>
verifica_anagramas :: Bool
